package com.mgtriffid.games.cotta.server.impl

import com.mgtriffid.games.cotta.core.CottaEngine
import com.mgtriffid.games.cotta.core.CottaGame
import com.mgtriffid.games.cotta.core.entities.EntityId
import com.mgtriffid.games.cotta.core.entities.InputComponent
import com.mgtriffid.games.cotta.core.entities.PlayerId
import com.mgtriffid.games.cotta.core.entities.TickProvider
import com.mgtriffid.games.cotta.core.entities.impl.CottaStateImpl
import com.mgtriffid.games.cotta.core.loop.impl.FixedRateLoopBody
import com.mgtriffid.games.cotta.core.serialization.DeltaRecipe
import com.mgtriffid.games.cotta.core.serialization.InputRecipe
import com.mgtriffid.games.cotta.core.serialization.StateRecipe
import com.mgtriffid.games.cotta.core.systems.CottaSystem
import com.mgtriffid.games.cotta.network.ConnectionId
import com.mgtriffid.games.cotta.network.CottaServerNetwork
import com.mgtriffid.games.cotta.network.purgatory.EnterGameIntent
import com.mgtriffid.games.cotta.server.ClientsInputProvider
import com.mgtriffid.games.cotta.server.CottaGameInstance
import com.mgtriffid.games.cotta.server.DataForClients
import com.mgtriffid.games.cotta.core.simulation.SimulationInput
import com.mgtriffid.games.cotta.server.ServerSimulation
import com.mgtriffid.games.cotta.server.ServerToClientDataChannel
import jakarta.inject.Inject
import mu.KotlinLogging
import kotlin.reflect.KClass

private val logger = KotlinLogging.logger {}

class CottaGameInstanceImpl<SR: StateRecipe, DR: DeltaRecipe, IR: InputRecipe> @Inject constructor(
    val game: CottaGame,
    val engine: CottaEngine<SR, DR, IR>,
    val network: CottaServerNetwork,
    val clientsInputProvider: ClientsInputProvider,
    val clientsGhosts: ClientsGhosts,
): CottaGameInstance {
    private val historyLength = 8
    @Volatile var running = true
    private val tickProvider = TickProvider.getInstance()
    private val state = CottaStateImpl(historyLength, tickProvider)
    private val serverSimulation = ServerSimulation.getInstance(state, tickProvider, historyLength)

    private val serverInputProvider = game.serverInputProvider

    // should be generated by network? Yes, probably.
    private val serverToClientDataChannel = ServerToClientDataChannel.getInstance(
        tickProvider = tickProvider,
        clientsGhosts = clientsGhosts,
        network = network,
        stateSnapper = engine.getStateSnapper(),
        snapsSerialization = engine.getSnapsSerialization(),
        inputSnapper = engine.getInputSnapper(),
        inputSerialization = engine.getInputSerialization()
    )

    override fun run() {
        registerComponents()
        initializeState()
        registerSystems()
        logger.debug { "Tick length is ${game.config.tickLength}" }
        val loop = FixedRateLoopBody(
            tickLengthMs = game.config.tickLength,
            startsAt = System.currentTimeMillis()
        ) {
            tick()
        }
        loop.start()
    }

    // TODO probably this is wrong place
    private fun registerComponents() {
        game.componentClasses.forEach {
            engine.getComponentsRegistry().registerComponentClass(it)
        }
        game.inputComponentClasses.forEach {
            engine.getComponentsRegistry().registerInputComponentClass(it)
        }
        serverSimulation.setMetaEntitiesInputComponents(game.metaEntitiesInputComponents)
    }

    private fun initializeState() {
        game.initializeServerState(state)
    }

    private fun registerSystems() {
        game.serverSystems.forEach { serverSimulation.registerSystem(it as KClass<CottaSystem>) }
    }

    private fun tick() {
        logger.debug { "Tick is happening: advancing from tick ${tickProvider.tick} to ${tickProvider.tick + 1}" }
        fetchInput()
        simulate()
        dispatchDataToClients()
    }

    private fun fetchInput() {
        val intents = network.drainEnterGameIntents()
        intents.forEach { (connectionId, intent) ->
            registerPlayer(connectionId, intent)
        }
        val input = fetchIncomingInput()
        serverSimulation.setInputForUpcomingTick(input)
    }

    private fun registerPlayer(connectionId: ConnectionId, intent: EnterGameIntent) {
        logger.trace { "Received an intent to enter the game from connection '${connectionId.id}'" }
        val playerId = serverSimulation.enterGame(intent)
        clientsGhosts.addGhost(playerId, connectionId)
    }

    private fun fetchIncomingInput(): SimulationInput {
        val clientsInput = clientsInputProvider.getInput()
        val clientsOwnedEntitiesInput = clientsInput

        val serverOwnedEntitiesInput = serverInputProvider.input(state.entities())

        val inputs = clientsOwnedEntitiesInput.input + serverOwnedEntitiesInput

        logger.trace { "Incoming input has ${inputs.size} entries" }

        inputs.forEach { (eId, components) ->
            logger.trace { "Inputs for entity $eId:" }
            components.forEach { logger.trace { it } }
        }

        return object: SimulationInput {
            // TODO protect against malicious client sending input for entity not belonging to them
            override fun inputsForEntities(): Map<EntityId, Collection<InputComponent<*>>> {
                return inputs
            }

            override fun playersSawTicks(): Map<PlayerId, Long> {
                return clientsInput.playersSawTicks
            }
        }
    }

    private fun simulate() {
        serverSimulation.tick()
    }

    private fun dispatchDataToClients() {
        logger.debug { "Preparing data to send to clients" }
        val data = serverSimulation.getDataToBeSentToClients()
        send(data)
    }

    private fun send(data: DataForClients) {
        serverToClientDataChannel.send(data)
    }
}
